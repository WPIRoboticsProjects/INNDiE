package edu.wpi.axon.aws.db

import arrow.fx.IO
import arrow.fx.extensions.fx
import com.amazonaws.regions.Regions
import com.amazonaws.services.rds.AmazonRDSClient
import com.amazonaws.services.rds.model.CreateDBClusterRequest
import com.amazonaws.services.rds.model.DBCluster
import com.amazonaws.services.rds.model.DescribeDBClustersRequest
import com.amazonaws.services.rds.model.ScalingConfiguration
import com.amazonaws.services.rds.model.VpcSecurityGroupMembership
import mu.KotlinLogging
import org.koin.core.KoinComponent
import org.koin.core.inject
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.ec2.Ec2Client
import software.amazon.awssdk.services.ec2.model.IpPermission
import software.amazon.awssdk.services.ec2.model.IpRange
import software.amazon.awssdk.services.ec2.model.Ipv6Range

/**
 * Configures a Job DB in RDS.
 */
class RDSJobDBConfigurator : KoinComponent {

    private val regions: Regions by inject()
    private val region: Region by inject()
    private val ec2Client by lazy { Ec2Client.builder().region(region).build() }
    private val rdsClient by lazy { AmazonRDSClient.builder().withRegion(regions).build() }

    private fun ensureDBCluster(): IO<DBCluster> = IO {
        val clusters = rdsClient.describeDBClusters(
            DescribeDBClustersRequest()
                .withDBClusterIdentifier(clusterId)
        ).dbClusters
        LOGGER.debug { "Got clusters: ${clusters.joinToString { it.dbClusterIdentifier }}" }
        check(clusters.size == 1)
        clusters.first()
    }.redeemWith(
        {
            LOGGER.warn { "Did not find DB cluster with id $clusterId. Creating a new DB cluster." }
            ensureSG().flatMap { sgId ->
                IO {
                    rdsClient.createDBCluster(
                        CreateDBClusterRequest()
                            .withDBClusterIdentifier(clusterId)
                            .withEngine("aurora")
                            .withEngineVersion("5.6.10a")
                            .withEngineMode("serverless")
                            .withScalingConfiguration(
                                ScalingConfiguration().withMinCapacity(1)
                                    .withMaxCapacity(2)
                                    .withSecondsUntilAutoPause(300)
                                    .withAutoPause(true)
                            )
                            .withMasterUsername("axonusername")
                            .withMasterUserPassword("axonpassword")
                            .withEnableHttpEndpoint(true)
                            .withVpcSecurityGroupIds(sgId)
                    )
                }
            }
        },
        { IO.just(it) }
    )

    private fun ensureDBClusterHasCorrectSG(dbCluster: DBCluster): IO<Unit> = IO.fx {
        val sgId = ensureSG().bind()
        val sg = VpcSecurityGroupMembership().withVpcSecurityGroupId(sgId).withStatus("active")
        val vpcSecurityGroups = dbCluster.vpcSecurityGroups
        if (!vpcSecurityGroups.any { it == sg }) {
            // SG is not present, need to add it
            dbCluster.setVpcSecurityGroups(vpcSecurityGroups + sg)
        }
    }

    /**
     * Ensures the correct SecurityGroup exists.
     *
     * @return The SecurityGroup id.
     */
    private fun ensureSG(): IO<String> = IO {
        ec2Client.describeSecurityGroups {
            it.groupNames(rdsSecurityGroupName)
        }.securityGroups()
    }.flatMap { rdsGroups ->
        IO {
            rdsGroups.first {
                it.groupName() == rdsSecurityGroupName
            }.groupId()
        }
    }.redeemWith(
        {
            LOGGER.debug { "SecurityGroup $rdsSecurityGroupName not found. Creating one." }
            createSG()
        },
        { IO.just(it) }
    )

    private fun createSG(): IO<String> = IO {
        LOGGER.debug { "Creating new SecurityGroup $rdsSecurityGroupName." }
        val sg = ec2Client.createSecurityGroup {
            it.groupName(rdsSecurityGroupName)
                .description("Axon autogenerated for RDS.")
        }.groupId()

        ec2Client.authorizeSecurityGroupIngress {
            it.groupId(sg)
                .ipPermissions(
                    IpPermission.builder()
                        .fromPort(3306)
                        .toPort(3306)
                        .ipProtocol("TCP")
                        .ipRanges(IpRange.builder().cidrIp("0.0.0.0/0").build())
                        .ipv6Ranges(Ipv6Range.builder().cidrIpv6("::/0").build())
                        .build()
                )
        }

        ec2Client.authorizeSecurityGroupEgress {
            it.groupId(sg)
                .ipPermissions(
                    IpPermission.builder()
                        .fromPort(-1)
                        .toPort(-1)
                        .ipProtocol("-1")
                        .ipRanges(IpRange.builder().cidrIp("0.0.0.0/0").build())
                        .ipv6Ranges(Ipv6Range.builder().cidrIpv6("::/0").build())
                        .build()
                )
        }

        sg
    }

    companion object {
        private val LOGGER = KotlinLogging.logger { }
        private const val clusterId = "axon-cluster"
        private const val rdsSecurityGroupName = "axon-rds-autogenerated"
    }
}
